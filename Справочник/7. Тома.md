# Проблемы записи данных только в слой контейнера

## Основные недостатки:

❌ **Потеря данных** при удалении контейнера  
❌ **Снижение производительности** из-за драйвера хранилища  
❌ **Сложность управления** данными (тесная связь с контейнером)  
❌ **Потеря гибкости** и "легковесности" контейнеров

## Решение:
Использование **томов (volumes)** для хранения данных

# Тома
Тома предназначены для постоянного хранения данных. Для аписи данных большого объема лучше использовать тома. 

<br>

**Том** - это каталог в той части хост-системы, где находится Docker. Он подключен к каталогу в контейнере, чтобы можно было аписывать и считывать данные. Данные контейнера хранятся в хост-системе, а значит, даже при удалении контейнера
все данные остаются. Тома - это просто физическая файловая система на хосте, подключенная к виртуальной файловой системе в Docker.  

# Практика
В хост системе сделаем следующее:
```shell
mkdir -p root/testing # создадим директорию
ls # убедимся, что создано
testinng # вывод 
```

Теперь запустим контейнер:
```shell
docker run -it --name myalpine -v C:/Users/user/root/testing:/test1 alpine:latest /bin/sh

ls -ltr
```
`docker run -it --name myalpine -v C:/Users/user/root/testing:/test1 alpine:latest /bin/sh` — этот код запускает контейнер из образа Alpine в интерактивном режиме (`-i`) с подключенным терминалом (`-t`). с именем myalpine, Мы также
указываем флаг `-v` (или --volume, т. е. том), чтобы подключить каталог `C:/Users/user/root/testing` в контейнер по пути `/test1`, и запускает внутри контейнера интерактивную оболочку `/bin/sh`. Мы не указываем `-d`, потому что хотим войти в контейнер напрямую, а не запускать его в фоновом режиме. При этом нужно учесть, что путь в хотс системе должен быть абсолютным.   

<br> 

`ls -ltr`
- `ls` — выводит список файлов и папок в текущем каталоге.  
- Опция `-l` выводит подробную информацию о каждом файле: права доступа, владельца, размер, дату и время последнего изменения.  
- Опция `-t` сортирует список по времени изменения (сначала новые файлы).  
- Опция `-r` меняет порядок на обратный, так что вывод идет с самого старого изменения к новому.  

Вывод:  
```bash
total 56
drwxr-xr-x   11 root     root          4096 Jul 15 10:42 var
drwxr-xr-x    7 root     root          4096 Jul 15 10:42 usr
drwxr-xr-x    2 root     root          4096 Jul 15 10:42 home
drwxr-xr-x    2 root     root          4096 Jul 15 10:42 bin
drwxr-xr-x    2 root     root            40 Sep 29 07:24 test1 # наша директория
```

Как и ожидалось, в контейнере содержится каталог `test1`.  
```bash
docker start myalpine -- запускаем контейнер
myalpine

docker exec -it myalpine sh -- заходим внутрь и запуска shell
/ # ls -- смотрим на список файлов и папок
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    test1  tmp    usr    var
/ # cd test1 -- переходим в прокинутую test1
/test1 # ls
1.txt -- дописываем в файл строку 
/test1 # echo hello >> 1.txt
/test1 # cat 1.txt
hello
/test1 #
```
