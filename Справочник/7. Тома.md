# Проблемы записи данных только в слой контейнера

## Основные недостатки:

❌ **Потеря данных** при удалении контейнера  
❌ **Снижение производительности** из-за драйвера хранилища  
❌ **Сложность управления** данными (тесная связь с контейнером)  
❌ **Потеря гибкости** и "легковесности" контейнеров

## Решение:
Использование **томов (volumes)** для хранения данных

# Тома
Тома предназначены для постоянного хранения данных. Для аписи данных большого объема лучше использовать тома. 

<br>

**Том** - это каталог в той части хост-системы, где находится Docker. Он подключен к каталогу в контейнере, чтобы можно было аписывать и считывать данные. Данные контейнера хранятся в хост-системе, а значит, даже при удалении контейнера
все данные остаются. Тома - это просто физическая файловая система на хосте, подключенная к виртуальной файловой системе в Docker.  

# Практика
В хост системе сделаем следующее:
```shell
mkdir -p root/testing # создадим директорию
ls # убедимся, что создано
testinng # вывод 
```

Теперь запустим контейнер:
```shell
docker run -it --name myalpine -v C:/Users/user/root/testing:/test1 alpine:latest /bin/sh

ls -ltr
```
`docker run -it --name myalpine -v C:/Users/user/root/testing:/test1 alpine:latest /bin/sh` — этот код запускает контейнер из образа Alpine в интерактивном режиме (`-i`) с подключенным терминалом (`-t`). с именем myalpine, Мы также
указываем флаг `-v` (или --volume, т. е. том), чтобы подключить каталог `C:/Users/user/root/testing` в контейнер по пути `/test1`, и запускает внутри контейнера интерактивную оболочку `/bin/sh`. Мы не указываем `-d`, потому что хотим войти в контейнер напрямую, а не запускать его в фоновом режиме. При этом нужно учесть, что путь в хотс системе должен быть абсолютным.   

<br> 

`ls -ltr`
- `ls` — выводит список файлов и папок в текущем каталоге.  
- Опция `-l` выводит подробную информацию о каждом файле: права доступа, владельца, размер, дату и время последнего изменения.  
- Опция `-t` сортирует список по времени изменения (сначала новые файлы).  
- Опция `-r` меняет порядок на обратный, так что вывод идет с самого старого изменения к новому.  

Вывод:  
```bash
total 56
drwxr-xr-x   11 root     root          4096 Jul 15 10:42 var
drwxr-xr-x    7 root     root          4096 Jul 15 10:42 usr
drwxr-xr-x    2 root     root          4096 Jul 15 10:42 home
drwxr-xr-x    2 root     root          4096 Jul 15 10:42 bin
drwxr-xr-x    2 root     root            40 Sep 29 07:24 test1 # наша директория
```

Как и ожидалось, в контейнере содержится каталог `test1`.  
```bash
docker start myalpine -- запускаем контейнер
myalpine

docker exec -it myalpine sh -- заходим внутрь и запуска shell
/ # ls -- смотрим на список файлов и папок
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    test1  tmp    usr    var
/ # cd test1 -- переходим в прокинутую test1
/test1 # ls
1.txt -- дописываем в файл строку 
/test1 # echo hello >> 1.txt
/test1 # cat 1.txt
hello
/test1 #
```
Данные не удаляются из тома даже после удаления контейнера:
```shell
docker rm myalpine
myalpine
cd testing
ls
Каталог: C:\Users\user\root\testing
1.txt
```

# Создание именованого тома
Создадим именованый том:
```shell
docker volume create myvolume
myvolume # вывод
```

<br>

Посмотрим на том пристальнее:
```shell
docker inspect volume myvolume
```
Вывод:
```json
[
    {
        "CreatedAt": "2025-09-29T08:43:14Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/myvolume/_data",
        "Name": "myvolume",
        "Options": null,
        "Scope": "local"
    }
]
``` 

<br> 

Нас интересует вот эта информация: `"Mountpoint": "/var/lib/docker/volumes/myvolume/_data"` каталог находится внутри wsl.
Его мы будем сопоставлять с контейнером.  
```bash
docker run -dit --name mycentos -v myvolume:test centos:latest
```
Так не только мы сохраним данные послу удаления но и можем к ожнмоу тому подключать много контейнеров.
```bash
# Создаем контейнер в фоне с томом
docker run -dit --name myalpine -v myvolume:/test_1 alpine:latest
# Вывод: ID контейнера (успешно создан)
cabec24c61d531298b976c2b71c553db378bffbe11e40afec46befa6bf012b38

# Смотрим работающие контейнеры
docker ps
# Вывод: контейнер myalpine работает 11 секунд
CONTAINER ID   IMAGE           COMMAND     CREATED          STATUS          PORTS     NAMES
cabec24c61d5   alpine:latest   "/bin/sh"   12 seconds ago   Up 11 seconds             myalpine

# Подключаемся к контейнеру
docker exec -it myalpine sh
# Вывод: попали внутрь контейнера (командная строка сменилась на / #)
/ # 

# Смотрим содержимое корневой папки
ls
# Вывод: видим папку test_1 (наш том) среди системных папок
bin     etc     lib     mnt     proc    run     srv     test_1  usr
dev     home    media   opt     root    sbin    sys     tmp     var

# Переходим в папку тома
cd test_1
# Вывод: теперь находимся в папке тома (приглашение /test_1 #)
/test_1 # 
```



